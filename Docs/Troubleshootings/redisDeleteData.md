> 작성자 : 이정수

# redis del로 String 데이터가 지워지지 않는 문제

## 문제
redis의 del 함수로도 String 데이터가 지워지지 않는 문제를 겪었습니다.
정상적으로 함수가 실행되었음에도  데이터가 지워지지 않는 문제로 플레이어의 진행 데이터를 소거할 수 없는 치명적인 상황이었습니다.

## 예측

- 트랜잭션 실패 : 트랜잭션을 이용하진 않으니 이 경우엔 해당하지 않습니다.
- 분산 환경 문제 : 클러스터를 이용하지 않으니 이 경우에도 해당하지 않습니다.
- 메모리 문제 : unlink 명령어는 정상 동작하며, 메모리도 여유 공간이 있었으니 이 경우에도 해당하지 않습니다.
- 만료된 TTL : 이미 TTL이 만료되었지만 삭제는 정상적으로 안되었을 때 삭제 명령어가 안될 수 있지만 TTL이 50분 이상 남았었기에 해당하지 않습니다.

## 고려사항

- 구동중인 서버의 성능 : NAS 환경에서 Docker로 실행중이었기에 CPU보단 메모리와 디스크 성능에 문제가 있을 수 있다 판단 했습니다.
- 네트워크 품질 : 500mb 넷이지만 가정용에 저품질 ddns 서비스로 다소 불안정한 품질을 갖고 있습니다.

## 고려사항2 - del vs unlink

### 성능차이

DEL은 즉시 키를 삭제하고 메모리를 해제하는 동작을 Redis의 메인 스레드에서 처리합니다. 이는 키의 크기가 작을 때는 문제가 되지 않지만, 키가 포함하는 데이터가 매우 클 경우 성능에 영향을 줄 수 있습니다. 큰 데이터의 경우 DEL 명령어가 메인 스레드를 차단하여 전체 서버 성능이 저하될 수 있습니다. 반면에 UNLINK는 데이터를 메모리에서 즉시 해제하지 않고, 비동기적으로 다른 스레드에서 메모리 회수를 처리합니다. 이렇게 하면 메인 스레드에서 성능 저하 없이 키를 제거할 수 있습니다. 따라서 대용량 데이터를 처리할 때는 DEL 대신 UNLINK를 사용하는 것이 훨씬 효율적입니다.

하지만 여기서 다루는 데이터는 대요량은 아닙니다만 다음 요소가 더 큰 영향을 끼친 것 같습니다.

### 메모리 회수 방식
DEL은 키와 관련된 모든 데이터를 한 번에 처리해야 하므로, 특히 많은 요소를 가진 리스트, 해시, 세트 등의 복합 데이터 구조일 때 시간이 오래 걸릴 수 있습니다. 반면에 UNLINK는 키를 즉시 Redis의 키 스페이스에서 제거하고, 나머지 메모리 해제 작업은 비동기적으로 처리되기 때문에, 특히 큰 데이터의 경우 성능이 훨씬 우수합니다

## 해결
unlink로 데이터를 제거하는 방식이 제대로 동작한 이유는 메모리 회수 방식에서의 차이 처럼 일단 키 스페이스에서만 우선 삭제후 외부론 삭제 된 것 으로 알리고 있기 때문인 것 같습니다.



